import numpy as np
import matplotlib.pyplot as plt
from math import sin, cos

# Константы
mu = 398600.4415
Re = 6378.1365
J2 = 0.108262668355315E-02
omega_earth = 7.292115085e-5
sigma = 0.01
F = 1 / 298.2525784
def rk4(func, t0: float, x0: np.ndarray, h: float) -> np.ndarray:
    k1 = func(t0, x0)
    k2 = func(t0 + h * 0.5, x0 + k1 * h * 0.5)
    k3 = func(t0 + h * 0.5, x0 + k2 * h * 0.5)
    k4 = func(t0 + h, x0 + k3 * h)
    return x0 + h * (k1 + 2*k2 + 2*k3 + k4) / 6

atmosphere_params = [
    (150, 180, 2.070e-9, 22.523),
    (180, 200, 5.464e-10, 29.740),
    (200, 250, 2.789e-10, 37.105),
    (250, 300, 7.248e-11, 45.546),
    (300, 350, 2.418e-11, 53.628),
    (350, 400, 9.518e-12, 53.298),
    (400, 450, 3.725e-12, 58.515),
    (450, 500, 1.585e-12, 60.828),
    (500, 600, 6.967e-13, 63.822),
    (600, 700, 1.454e-13, 71.835),
    (700, 800, 3.614e-14, 88.667),
    (800, 900, 1.170e-14, 124.64),
    (900, 1000, 5.245e-15, 181.05),
    (1000, 1500, 3.019e-15, 268.00)
]

CS = np.array([
    .000000000000000E+00, .000000000000000E+00, .000000000000000E+00, -.108262668355315E-02,
    -.241400000000137E-09, .154310000000448E-08, .157446037456404E-05, -.903803806638557E-06,
    .253265648533224E-05, .219263852916859E-05, .268424890296779E-06, .308989206880511E-06,
    -.211437612437343E-06, .100548778064384E-06, .197222559005907E-06, .161962159136700E-05,
    -.508799360403833E-06, -.449144872839336E-06, .784175859843762E-07, .148177868295612E-06,
    .592099402629132E-07, -.120077667633627E-07, -.398407411766274E-08, .652571425370430E-08,
    .227296082868698E-06, -.531803015007603E-07, -.808586947660730E-07, .105587168390898E-06,
    -.523291936216342E-07, -.149300637492288E-07, -.709734236889537E-08, -.229930029012696E-08,
    .386712335850938E-09, .430822462051790E-09, -.164818262628074E-08, -.540681239107085E-06,
    -.598656698653037E-07, .206841175080183E-07, .599291238543649E-08, -.464930357082141E-07,
    .118542072651316E-08, .187163685038141E-09, -.326361778052326E-09, -.178450285009087E-08,
    -.215594106911947E-09, -.432981337156651E-09, .225434970831008E-11, -.552609366454075E-10,
    .352359908418236E-06, .204845995321168E-06, .698503096431362E-07, .328432702681306E-07,
    .926967113808219E-08, .352709151564226E-08, -.305943880493392E-08, -.584213577003763E-09,
    -.262893842692888E-09, .685778101138068E-12, .627778171919269E-11, -.249081643523580E-10,
    .105356930349944E-10, .202544296663295E-13, .453404227180241E-12, .204799466985351E-06,
    .160403959801804E-07, .405480289972938E-07, .659520391291287E-08, .537301949210593E-08,
    -.193988888910329E-09, -.872954588511538E-09, -.319251713793336E-09, .913943149290105E-10,
    -.462183965775986E-11, .161353295978680E-10, -.183592365938716E-11, .863661946419391E-11,
    .343070290803931E-12, .381123970280743E-12, -.158188595910567E-12, .153651294804239E-12,
    .120616967365074E-06, .931712333940155E-07, .140896376080005E-07, .153973452620488E-08,
    -.223177405361102E-08, -.121536485386862E-08, -.560998446570740E-09, -.770320133653270E-11,
    .166584314948016E-10, -.169954644681777E-11, -.553453788475167E-11, .827837203891598E-12,
    .294330017499792E-11, -.225592760008784E-12, -.183947129374371E-12, .615915977093613E-13,
    -.100856971151662E-14, -.367851284406190E-14, .744533053689097E-14, .241145438625548E-06,
    .516030047285826E-07, -.811410140026305E-07, -.560348352870147E-08, -.306683731148400E-08,
    -.402237709502505E-10, -.896536677720559E-09, -.495177735069951E-10, -.466932158351232E-10,
    -.306309899321040E-11, -.313743770081624E-11, -.260900996402294E-12, -.552270498938737E-12,
    .683019997161138E-14, -.283346835808612E-14, .463817276806103E-14, -.105231478979302E-13,
    .233179879648038E-14, -.699618084910621E-15, .417729666030675E-15, -.997796839050699E-16,
    -.244402148324628E-06, .895449118833448E-08, -.158564025342409E-07, .964619099851446E-09,
    -.512931943745245E-08, -.142927655995879E-09, -.683255779765094E-09, -.164036789342448E-10,
    -.268075043734274E-10, .150332378515930E-11, .196838066166010E-11, -.467520166639647E-14,
    .135820156602333E-12, .170904170104544E-14, -.373003245441369E-13, -.285040573661091E-15,
    .116219383472894E-14, -.193232749398660E-15, .256879338156180E-15, -.495199098706624E-16,
    -.173989229527363E-16, .931276255535740E-17, -.140934699550898E-16, .188626318279000E-06,
    -.306085607399829E-07, -.246652822451334E-07, .652283734010943E-09, .146431603701535E-08,
    .146760231968497E-09, .909866579240017E-10, -.213223035726913E-10, .128845256792074E-11,
    .823572701598711E-12, .208290994595930E-12, .809843399611353E-14, .928981169975425E-13,
    -.415107667970791E-14, .790931968551455E-14, -.563595563134036E-15, .376133302422002E-15,
    .102472295500760E-15, .612323874078108E-16, -.184220438686178E-17, .919807581236179E-17,
    .494768302621230E-18, -.280557606668426E-18, -.224005907480156E-19, -.100345663956265E-18,
    .219788001661471E-06, -.279743869668850E-07, .212712874033412E-07, .227041797670368E-08,
    -.254698406309541E-08, -.671317353906631E-10, .298330187649240E-09, -.736453471068429E-12,
    -.280786695099909E-11, .108811551013265E-11, .122628827357883E-11, -.537038402065433E-13,
    -.983140666557613E-14, .319834292288020E-15, -.785636339163314E-15, -.110722451802398E-15,
    -.117958445497952E-15, .265575848401189E-16, .486287505910009E-16, .459359711887067E-17,
    -.412112624532551E-17, -.585618139105484E-18, -.628679154772575E-19, -.583302524184413E-19,
    .163896334118256E-18, -.224221605189319E-19, .250751587869687E-19, -.130744533117743E-06,
    -.982591637229657E-08, .154901114269193E-07, -.134020695099735E-08, -.188311944815288E-09,
    .915589748728425E-10, .522039290418868E-10, .333369242651360E-12, -.411179002906532E-11,
    .377964272110903E-12, -.215565928865769E-12, -.190996003047557E-13, .242978617870030E-14,
    .283656685173521E-14, -.315643361426823E-15, -.213913329196777E-15, -.935725610164171E-16,
    .166185804191045E-16, .149851811097613E-16, .184883350015392E-17, -.683531529143143E-19,
    .729296869219631E-19, -.184987078369205E-18, .450948812734870E-20, -.166969263599744E-19,
    .235113058928146E-20, .329808827590420E-20, -.715805237931021E-21, -.664118935541100E-22,
    .823528409456142E-08, .512418911018179E-08, .557938100505911E-08, -.704853993244966E-09,
    -.101774872643307E-08, .112294621015169E-09, .372366875949968E-10, -.582165256749363E-11,
    .927377306683344E-12, .120143889492635E-12, .777370811271697E-13, .219791554985433E-13,
    -.244367501550045E-13, .281172327299107E-14, .250815727118881E-15, -.112097926527925E-15,
    .770165143597355E-16, .345450289384329E-17, .100755629558680E-16, .229278603927888E-18,
    .322430988954846E-18, -.214510301949965E-20, .347665347169362E-19, -.598789706646788E-20,
    .286940859053341E-20, -.572606576709191E-21, -.851180398629629E-22, .137478590051765E-22,
    -.645469819083201E-22, -.923083959625063E-23, -.227779823285141E-23, -.181139265111801E-07,
])

def get_atmosphere_density(h):
    if h < 150 or h >= 1500:
        return 0.0

    for h0, hmax, rho0, H in atmosphere_params:
        if h0 <= h < hmax:
            return rho0 * np.exp(-(h - h0) / H)

    return 0.0

def calculate_height(r_earth):
    x, y, z = r_earth
    e = np.sqrt(2 * F - F * F)
    dz = 0.0
    phi0 = -10
    i = 0

    xy2 = x * x + y * y

    while i < 10:
        stu_phi = (z + dz) / np.sqrt(xy2 + (z + dz) * (z + dz))
        N = Re / np.sqrt(1 - e * e * stu_phi * stu_phi)
        dz = N * e * e * stu_phi

        phi = np.arctan(stu_phi)
        if abs(phi - phi0) < 5e-8:
            break

        phi0 = phi
        i += 1
    phi = np.arctan((z + dz) / np.sqrt(xy2))
    lam = np.arctan2(y, x)
    h = np.sqrt(xy2 + (z + dz) * (z + dz)) - N
    return h

def earth_rotation_matrix(t):
    theta = omega_earth * t
    return np.array([
        [cos(theta), sin(theta), 0],
        [-sin(theta), cos(theta), 0],
        [0, 0, 1]
    ])

def rv_to_orbital_elements(r, v):
    c = np.cross(r, v)
    c_abs = np.linalg.norm(c)
    r_abs = np.linalg.norm(r)
    v_abs = np.linalg.norm(v)

    fl = np.cross(v, c) - mu * r / r_abs
    fl_abs = np.linalg.norm(fl)

    e = fl_abs / mu
    p = c_abs ** 2 / mu

    a = p / (1 - e ** 2)
    e_z = np.array([0, 0, 1])

    i = np.arccos(np.dot(c, e_z) / c_abs)
    node = np.cross(e_z, c)
    node = node / np.linalg.norm(node)
    Omega = np.arctan2(node[1], node[0])

    omega = np.arccos(np.dot(node, fl) / fl_abs)
    if fl[2] < 0:
        omega = 2 * np.pi - omega

    nu = np.arccos(np.dot(fl, r) / (fl_abs * r_abs))
    if np.dot(r, v) < 0:
        nu = 2 * np.pi - nu

    E = 2 * np.arctan(np.sqrt((1 - e) / (1 + e)) * np.tan(nu / 2))
    M = E - e * np.sin(E)

    return a, e, i, Omega, omega, M

def calc_geop_accel(r_earth, n_max=4):
    f = np.zeros(3)
    r_xy = np.linalg.norm(r_earth[:2])
    r_abs = np.linalg.norm(r_earth)

    if r_abs < 1e-6:
        return f

    x = r_earth / r_abs
    if r_xy < 1e-12:
        cosL = 1.0
        sinL = 0.0
    else:
        cosL = r_earth[0] / r_xy
        sinL = r_earth[1] / r_xy

    cosphi = r_xy / r_abs
    sinphi = x[2]

    R = Re / r_abs

    W1 = 0.0
    W2 = 0.0
    W3 = 0.0
    W4 = 0.0

    cosm1L = 1.0
    sinm1L = 0.0
    cosmL = cosL
    sinmL = sinL

    pos_mm = 1
    pos_mn1 = 0

    P_mm = 1.0
    R_m = R

    for m in range(1, n_max + 1):
        P_nm = P_mm
        P_n1m = 0.0
        pos_nm = pos_mm
        R_n = R_m
        n1 = m + 1

        dW2 = 0.0
        dW3 = 0.0

        for n in range(m, n_max + 1):
            P_nmR = P_nm * R_n

            dW = P_nmR * (CS[pos_nm] * cosmL + CS[pos_nm + 1] * sinmL)
            W1 += n1 * dW
            dW2 += dW
            dW3 += P_nmR * (-CS[pos_nm] * sinmL + CS[pos_nm + 1] * cosmL)
            W4 += P_nmR * (CS[pos_mn1] * cosm1L + CS[pos_mn1 + 1] * sinm1L)

            R_n *= R
            P_n2m = P_n1m
            P_n1m = P_nm
            n21 = n + n1
            P_nm = (n21 * sinphi * P_n1m - (n + m) * P_n2m) / (n1 - m)
            n1 += 1
            pos_mn1 = pos_mn1 + n21
            pos_nm = pos_nm + n21

        W2 += m * dW2
        W3 += m * dW3

        R_m *= R
        cosm1L = cosmL
        sinm1L = sinmL
        cosmL = cosm1L * cosL - sinm1L * sinL
        sinmL = cosm1L * sinL + sinm1L * cosL
        n21 = m + m + 1

        P_mm = n21 * cosphi * P_mm
        pos_mn1 = n21 + pos_mm
        pos_mm = pos_mn1 + 2

    P_n1m = 1.0
    P_nm = sinphi
    pos_mm = 0
    R_n = R
    W1 *= cosphi

    for n in range(1, n_max + 1):
        W1 += (n + 1) * CS[pos_mm] * R_n * P_nm
        if n == n_max:
            continue

        n1 = n + 1
        R_n *= R
        P_n2m = P_n1m
        P_n1m = P_nm
        n21 = n + n1
        P_nm = (n21 * sinphi * P_n1m - n * P_n2m) / n1
        pos_mm = pos_mm + n21

    coeff = -mu / (r_abs * r_abs)
    W2 = W4 * cosphi - W2 * sinphi
    f[2] = (W1 * sinphi - W2 * cosphi) * coeff
    W2 = W2 * sinphi
    f[0] = (W2 * cosL + W3 * sinL + W1 * x[0]) * coeff
    f[1] = (W2 * sinL - W3 * cosL + W1 * x[1]) * coeff

    return f


def numerical_model(t, X, n_max=4):
    r = X[:3]
    v = X[3:]
    r_norm = np.linalg.norm(r)
    a_central = -mu * r / r_norm ** 3

    omega_vec = np.array([0, 0, omega_earth])
    v_atm = np.cross(omega_vec, r)
    v_rel = v - v_atm
    h = calculate_height(r)
    rho = get_atmosphere_density(h)


    v_rel_m = v_rel * 1000
    v_rel_norm = np.linalg.norm(v_rel_m)
    a_atm_m = - sigma * rho * v_rel_norm * v_rel_m
    a_atm = a_atm_m * 0.001
    A = earth_rotation_matrix(t)
    r_earth = A @ r
    a_geop_earth = calc_geop_accel(r_earth, n_max)
    a_geop = A.T @ a_geop_earth

    a = a_central + a_atm + a_geop
    return np.concatenate([v, a])

def main():
    r0 = np.array([6873.987, 3036.358, -16.893])
    v0 = np.array([-1.836760, 2.715854, 6.435654])
    delta_t_total = 30 * 86400
    delta_t_step = 10 * 60
    t_points = np.arange(0, delta_t_total + delta_t_step, delta_t_step)
    n_points = len(t_points)

    y_sol = np.zeros((6, n_points))
    y_sol[:, 0] = np.concatenate([r0, v0])

    n_substeps = 10  # Число подшагов
    h = delta_t_step / n_substeps

    for i in range(1, n_points):
        t_start = t_points[i - 1]
        y_start = y_sol[:, i - 1]
        t_end = t_points[i]

        t_current = t_start
        y_current = y_start
        steps = 0

        while t_current < t_end - 1e-9 and steps < 100:
            y_current = rk4(numerical_model, t_current, y_current, h)
            t_current += h
            steps += 1
        y_sol[:, i] = y_current

    results = []
    for i in range(n_points):
        r = y_sol[:3, i]
        v = y_sol[3:, i]
        a, e, i_ang, Omega, omega, _ = rv_to_orbital_elements(r, v)
        results.append((a, e, Omega, omega))

    results = np.array(results)
    t_days = t_points / 86400

    plt.figure(figsize=(14, 10))

    plt.subplot(2, 2, 1)
    plt.plot(t_days, results[:, 0], 'b')
    plt.xlabel('Время, сут')
    plt.ylabel('a, км')
    plt.title('Большая полуось')
    plt.grid()

    plt.subplot(2, 2, 2)
    plt.plot(t_days, results[:, 1], 'b')
    plt.xlabel('Время, сут')
    plt.ylabel('e')
    plt.title('Эксцентриситет')
    plt.grid()

    plt.subplot(2, 2, 3)
    plt.plot(t_days, results[:, 2], 'b')
    plt.xlabel('Время, сут')
    plt.ylabel('Ω, рад')
    plt.title('Долгота восходящего узла')
    plt.grid()

    plt.subplot(2, 2, 4)
    plt.plot(t_days, results[:, 3], 'b')
    plt.xlabel('Время, сут')
    plt.ylabel('ω, рад')
    plt.title('Аргумент перицентра')
    plt.grid()

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()